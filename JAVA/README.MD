# Algorithm JAVA

## 전화번호 목록 [소스 코드](https://github.com/wanni0928/-algorithm/blob/master/JAVA/PhoneNumber_recap3.java)
1. 문제 설명
    전화번호부에 적힌 전화번호 중, 한 번호가 다른 번호의 접두어인 경우가 있는지 확인하려 합니다.
    전화번호가 다음과 같을 경우, 구조대 전화번호는 영석이의 전화번호의 접두사입니다.

    * 구조대 : 119
    * 박준영 : 97 674 223
    * 지영석 : 11 9552 4421

    전화번호부에 적힌 전화번호를 담은 배열 phone_book 이 solution 함수의 매개변수로 주어질 때, 어떤 번호가 다른 번호의 접두어인 경우가 있으면 false를 그렇지 않으면 true를 return 하도록 solution 함수를 작성해주세요.

2. 문제 인식
    * '어떤 번호가 다른 번호의 접두어'인 경우 : 특정 인덱스의 '번호'가  다른 인덱스의 '번호'에 0번 인덱스 부터 특정 인덱스의 길이 까지 포함된다.

    * 어떤 번호가 다른 번호의 접두어인 경우가 있으면 false : 위의 경우가 하나라도 된다면, 더이상 탐색할 필요가 없다.

    * 첫 번째 경우가 충족하려면 특정 인덱스의 값의 '길이'가 비교할 대상의 인덱스의 값의 '길이' 보다 짧아야 한다. : 배열을 값의 길이 순서로 오름차순으로 정렬하는 것이 더 효율적일 수 있다.

3. 문제 해결
    1. 배열의 순서를 값의 길이가 짧은 것 순서대로 재배열 한다.
    
    2. 0번 인덱스를 기준으로 다음 인덱스 까지 접두어로 포함이 되는지 확인한다.

    3. 포함되는 인덱스의 값이 있으면, false를 리턴하고, 프로그램을 끝낸다.
    
    4. 포함되는 인덱스의 값이 없다면, 1번 인덱스를 기준으로 다시 2번 과정을 진행한다.

    5. 2, 3, 4번 과정을 배열의 끝까지 살펴 봤음에도, 포함되는 인덱스의 값이 없다면, true를 리턴하고 프로그램을 끝낸다.

4. 해결방향
    1. for문을 이용하여, 배열의 길이 순으로 정리할 수 있지만, 좀더 가독성이 좋고, 시간복잡도도 줄일 수 있는 Arrays api의 sort 함수와 Comparator 인터페이스로 진행한다.(for -> n ~ n^2, Arrays, Comparator -> nlogn)

    2. 배열의 요소 하나씩 차례대로 살펴봐야 하기 때문에, 향상된 for문을 사용하고, 접두어로 포함되는 인덱스의 갯수를 리턴하기 위해, stream의 filter().count() 함수를 사용하고 그 갯수를 count 변수에 담는다.

    3. 그 갯수가 2개 이상일 경우(1개 이상으로 할 경우, 접두어의 기준으로 삼은 인덱스 의 갯수 까지 포함한다.) false를 리턴. 그렇지 않으면 true를 리턴한다.

5. 주의사항
    * Arrays api를 포함한 모든 스트림 기능은 병렬처리 기능을 가진다. 여기서 병렬 처리(Parallel Operation)은 멀티 코어 CPU환경에서 하나의 작업을 분할해서 각각의 코어가 병렬적으로 처리하는 것을 정의한다. 이러한 특성을 가져, 작업 처리 시간을 줄일 수 있다. 하지만, 요소의 수가 적고 요소당 처리 시간이 짧으면, 순차 처리가 오히려 병렬 처리보다 빠를 수 있다.

    * 요약하자면, java util 내의 api 함수를 사용하는 것이 무조건 빠르다고는 할 수 없다.

출처 [https://programmers.co.kr/learn/courses/30/lessons/42577](https://programmers.co.kr/learn/courses/30/lessons/42577)



## 완주하지 못한 선수 [소스 코드](https://github.com/wanni0928/-algorithm/blob/master/JAVA/marathon_myanswer.java)
1. 문제 설명
    수많은 마라톤 선수들이 마라톤에 참여하였습니다. 단 한 명의 선수를 제외하고는 모든 선수가 마라톤을 완주하였습니다.

    마라톤에 참여한 선수들의 이름이 담긴 배열 participant와 완주한 선수들의 이름이 담긴 배열 completion이 주어질 때, 완주하지 못한 선수의 이름을 return 하도록 solution 함수를 작성해주세요.

    * 제한사항
        마라톤 경기에 참여한 선수의 수는 1명 이상 100,000명 이하입니다.
        completion의 길이는 participant의 길이보다 1 작습니다.
        참가자의 이름은 1개 이상 20개 이하의 알파벳 소문자로 이루어져 있습니다.
        참가자 중에는 동명이인이 있을 수 있습니다.

2. 문제 인식
    * '참가자의 이름은 1개 이상 20개 이하의 알파벳 소문자로 이루어져 있습니다.' : 대소문자 구문x
    
    * 참가자 중에는 동명이인이 있을 수 있다. : 단순히 '이름'을 기준으로 진행하면, 중복 삭제가 될 수 있다.

    * 'completion의 길이는 participant의 길이보다 1 작습니다.' : 완주하지 못한 선수는 무조건 1명이다.

3. 문제 해결
    1. 같은 이름의 인덱스도 구분해야하기 때문에, HashMap으로 key-value의 관계를 이름, 중복횟수로 지정하고 인스턴스를 초기화 한다.

    2. '참가자 배열'을 향상된 for문을 돌려 해쉬맵에 "이름", 1로 put 하되, 같은 이름의 인덱스로 put을 하게 될때마다, 기존 '중복횟수'에서 1을 더한다.

    3. '경쟁자 배열' 향상된 for문을 돌려 동일하게 해쉬맵에 적용하되, 이미 적용된 해쉬맵이 검색될 때마다. 기존 중복횟수에서 -1을 한다.

    4. 해쉬맵 인스턴스가 두개의 for문을 거치면, 결과적으로 0 혹은 1의 값을 가진 키셋이 형성된다.
        해당 해쉬맵에 Iterator와 Entry를 이용해, 해쉬 테이블을 전체적으로 검색하고 그중에서 중복횟수 '값'이 1을 가진 키가 검색된다면, 그 키 값을 리턴하고, 프로그램을 끝낸다. 

4. 주의사항
    * 다른 사람의 풀이를 보면, 간혹 해쉬앱을 바로 for문에 적용하여, 검색하는 풀이를 볼 수 있는데, 코드의 길이와 가독성을 보면 언듯 더 편리해보이지만, EntrySet의 getValue()가 HashMap의 get() 보다 사용하는 함수의 갯수가 더 적고, 실행 속도도 빠르기 때문에, 해쉬에서 값이나 키를 출력할 때는 EntrySet을 사용하는 것이 결과적으로는 더 효율적이다.

    * [출처 : https://stackoverflow.com/questions/3870064/performance-considerations-for-keyset-and-entryset-of-map](https://stackoverflow.com/questions/3870064/performance-considerations-for-keyset-and-entryset-of-map)

출처 [https://programmers.co.kr/learn/courses/30/lessons/42576?language=java](https://programmers.co.kr/learn/courses/30/lessons/42576?language=java)

## 베스트 앨범 [소스코드](https://github.com/wanni0928/-algorithm/blob/master/JAVA/BestAlbum2.java)
1. 문제 설명
    베스트앨범
    스트리밍 사이트에서 장르 별로 가장 많이 재생된 노래를 두 개씩 모아 베스트 앨범을 출시하려 합니다. 노래는 고유 번호로 구분하며, 노래를 수록하는 기준은 다음과 같습니다.

    속한 노래가 많이 재생된 장르를 먼저 수록합니다.
    장르 내에서 많이 재생된 노래를 먼저 수록합니다.
    장르 내에서 재생 횟수가 같은 노래 중에서는 고유 번호가 낮은 노래를 먼저 수록합니다.
    노래의 장르를 나타내는 문자열 배열 genres와 노래별 재생 횟수를 나타내는 정수 배열 plays가 주어질 때, 베스트 앨범에 들어갈 노래의 고유 번호를 순서대로 return 하도록 solution 함수를 완성하세요.

    * 제한사항
        * genres[i]는 고유번호가 i인 노래의 장르입니다.
        * plays[i]는 고유번호가 i인 노래가 재생된 횟수입니다.
        * genres와 plays의 길이는 같으며, 이는 1 이상 10,000 이하입니다.
        * 장르 종류는 100개 미만입니다.
        * 장르에 속한 곡이 하나라면, 하나의 곡만 선택합니다.
        * 모든 장르는 재생된 횟수가 다릅니다.

2. 문제 인식
    * 장르 배열과 조회수 배열의 인덱스 번호는 서로 동일하다. -> 자료구조를 설계할때, 이 둘의 관계를 적극활용해야 한다.

    * 속한 노래가 많이 재생된 장르를 먼저 수록합니다. -> 장르별로 합계를 나타내는 자료구가 필요하다.
    
    * 장르 내에서 많이 재생된 노래를 먼저 수록합니다. -> 개별 곡의 장르의 조회수는 내림차순으로 정렬되어야 한다.

    * 장르 내에서 재생 횟수가 같은 노래 중에서는 고유 번호가 낮은 노래를 먼저 수록합니다. -> 조회수가 같다면, 인덱스의 오름차순으로 정렬.

3. 문제 해결
    1. 조회수 배열과 장르 배열의 인덱스 번호가 서로 연결됨 점과 객체지향 언어인 JAVA의 특성을 활용하여, Song 객체(인덱스 번호, 조회수, 장르)를 만든다.

    2. Song 객체를 주어진 배열(genres, plays)의 길이만큼, 인스턴스를 만들고, 정렬하는데, 특화된 ArrayList에 담는다.

    3. 문제에 주어진 곡들의 순서의 조건이 많으므로, Song 객체에 Comparable 인터페이스를 implements 한다.

    4. 곡들의 순서 조건은 다음과 같다.
        * 개별 곡들의 순서조건
            1. 조회수가 다르다면, 조회수의 내림차순으로 정렬
            2. 조회수가 같다면, 인데스번호의 오름차순으로 정렬

        * 장르별 곡들의 순서조건 
            1. 장르별로 많이 재생된, 즉 장르별로 조회수의 합계를 구하고, 그 합계의 내림차순으로 정렬.

        * 개별 곡(Song) 인스턴스들의 정렬 조건은, Comparable 인터페이스의 compareTo 메소드를 오버라이드해서 구현하고, 장르별 곡들의 순서조건은 Song 인스턴스들을 리스트에 담아, Collections의 sort 메소드와 Comparator를 활용한다.

        * 장르별 곡들의 순서조건을 구현하기 위해서는 '장르'와 '조회수 합계'를 담는 자료구조가 필요하다. 인덱스 별로 '장르', '조회수 합계'를 ArrayList로 담을 경우. 2차원 리스트로 구현해야 하는데, 이러한 자료구조는 나중에 개별곡마다 조건을 거칠때, 걸리는 시간복잡도가 n^2 이상이 될 수 있기 때문에, key값 만으로 한번에 value를 검색할 수 있는 HashMap의 자료구조로 구현한다.

        * 위의 정렬 조건을 거치고 나면, Song 인스턴스들을 담은 리스트는 장르별로 합계의 내림차 순으로, 그리고, 개별곡들의 인덱스 번호는 오름차순으로 조회수는 내림차순으로 정렬될 것이다.
        
        * 정렬된 Song 리스트를 for문으로 돌려 장르마다, 2개의 인덱스만 가져와서, answer 배열에 담아서 리턴한다. 

    5. 참고
        * [HashMap vs ArrayList 출처 : https://850530.tistory.com/74](https://850530.tistory.com/74)
        * [Comparable 출처 : https://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html](https://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html)
        * [Comparable과 Comparator 정렬 https://jeong-pro.tistory.com/173](https://jeong-pro.tistory.com/173)

    문제출처 [https://programmers.co.kr/learn/courses/30/lessons/42579](https://programmers.co.kr/learn/courses/30/lessons/42579)